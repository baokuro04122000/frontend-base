/* tslint:disable */
/* eslint-disable */
/**
 * SPG API document
 * This is a SPG API document
 *
 * The version of the OpenAPI document: 1.0.1
 * Contact: tpp@tpptechnology.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Create new users
 * @export
 * @interface AdminResetPassword
 */
export interface AdminResetPassword {
    /**
     * 
     * @type {number}
     * @memberof AdminResetPassword
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof AdminResetPassword
     */
    'password'?: string;
}
/**
 * Contract detail information
 * @export
 * @interface Contract
 */
export interface Contract {
    /**
     * 
     * @type {number}
     * @memberof Contract
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Contract
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof Contract
     */
    'supply_vendor_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Contract
     */
    'start_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof Contract
     */
    'end_date'?: string;
    /**
     * 
     * @type {number}
     * @memberof Contract
     */
    'base_amount'?: number;
    /**
     * 
     * @type {number}
     * @memberof Contract
     */
    'actual_amount'?: number;
}
/**
 * list contracts
 * @export
 * @interface ContractListResponse
 */
export interface ContractListResponse {
    /**
     * 
     * @type {number}
     * @memberof ContractListResponse
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof ContractListResponse
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof ContractListResponse
     */
    'total'?: number;
    /**
     * 
     * @type {Array<Contract>}
     * @memberof ContractListResponse
     */
    'list'?: Array<Contract>;
}
/**
 * 
 * @export
 * @interface CreateRoleRequest
 */
export interface CreateRoleRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateRoleRequest
     */
    'name': string;
}
/**
 * Error responses are sent when an error (e.g. unauthorized, bad request) occurred.
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * Error name.
     * @type {string}
     * @memberof ErrorResponse
     */
    'error': string;
    /**
     * 
     * @type {number}
     * @memberof ErrorResponse
     */
    'error_code'?: number;
    /**
     * Show detail about the error, debug information. This is usually not available and has to be enabled.
     * @type {string}
     * @memberof ErrorResponse
     */
    'error_message'?: string;
}
/**
 * 
 * @export
 * @interface ForgotPassword
 */
export interface ForgotPassword {
    /**
     * 
     * @type {string}
     * @memberof ForgotPassword
     */
    'email': string;
}
/**
 * list withdraw request
 * @export
 * @interface ListWithdrawRequest
 */
export interface ListWithdrawRequest {
    /**
     * 
     * @type {number}
     * @memberof ListWithdrawRequest
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof ListWithdrawRequest
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof ListWithdrawRequest
     */
    'total'?: number;
    /**
     * 
     * @type {Array<WithdrawRequest>}
     * @memberof ListWithdrawRequest
     */
    'list'?: Array<WithdrawRequest>;
}
/**
 * permission detail information
 * @export
 * @interface PermissionDetail
 */
export interface PermissionDetail {
    /**
     * 
     * @type {number}
     * @memberof PermissionDetail
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PermissionDetail
     */
    'name'?: string;
}
/**
 * permission detail information
 * @export
 * @interface PermissionNewDetail
 */
export interface PermissionNewDetail {
    /**
     * 
     * @type {number}
     * @memberof PermissionNewDetail
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PermissionNewDetail
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PermissionNewDetail
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface ResetPassword
 */
export interface ResetPassword {
    /**
     * 
     * @type {string}
     * @memberof ResetPassword
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface Response
 */
export interface Response {
    /**
     * 
     * @type {string}
     * @memberof Response
     */
    'message': string;
}
/**
 * Role detail information
 * @export
 * @interface Role
 */
export interface Role {
    /**
     * 
     * @type {number}
     * @memberof Role
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Role
     */
    'status'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    'start_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    'end_date'?: string;
    /**
     * 
     * @type {number}
     * @memberof Role
     */
    'base_amount'?: number;
    /**
     * 
     * @type {number}
     * @memberof Role
     */
    'actual_amount'?: number;
}
/**
 * role detail information
 * @export
 * @interface RoleDetail
 */
export interface RoleDetail {
    /**
     * 
     * @type {number}
     * @memberof RoleDetail
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof RoleDetail
     */
    'name'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RoleDetail
     */
    'permissions'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof RoleDetail
     */
    'status'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof RoleDetail
     */
    'total_users'?: number;
    /**
     * 
     * @type {string}
     * @memberof RoleDetail
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof RoleDetail
     */
    'updated_at'?: string;
}
/**
 * role detail by id information
 * @export
 * @interface RoleListByIdDetail
 */
export interface RoleListByIdDetail {
    /**
     * 
     * @type {number}
     * @memberof RoleListByIdDetail
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof RoleListByIdDetail
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RoleListByIdDetail
     */
    'status'?: boolean;
    /**
     * 
     * @type {Array<PermissionDetail>}
     * @memberof RoleListByIdDetail
     */
    'permissions'?: Array<PermissionDetail>;
    /**
     * 
     * @type {string}
     * @memberof RoleListByIdDetail
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof RoleListByIdDetail
     */
    'updated_at'?: string;
    /**
     * 
     * @type {number}
     * @memberof RoleListByIdDetail
     */
    'total_users'?: number;
}
/**
 * list user detail
 * @export
 * @interface RoleListResponse
 */
export interface RoleListResponse {
    /**
     * 
     * @type {Array<RoleDetail>}
     * @memberof RoleListResponse
     */
    'list'?: Array<RoleDetail>;
}
/**
 * 
 * @export
 * @interface UpdateUserNameRequest
 */
export interface UpdateUserNameRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserNameRequest
     */
    'full_name': string;
}
/**
 * Create new users
 * @export
 * @interface UserCreate
 */
export interface UserCreate {
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    'full_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    'email'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof UserCreate
     */
    'roles'?: Array<number>;
}
/**
 * 
 * @export
 * @interface UserCredentialResponse
 */
export interface UserCredentialResponse {
    /**
     * 
     * @type {string}
     * @memberof UserCredentialResponse
     */
    'access_token'?: string;
    /**
     * 
     * @type {UserCredentialResponseData}
     * @memberof UserCredentialResponse
     */
    'data'?: UserCredentialResponseData;
}
/**
 * 
 * @export
 * @interface UserCredentialResponseData
 */
export interface UserCredentialResponseData {
    /**
     * 
     * @type {number}
     * @memberof UserCredentialResponseData
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserCredentialResponseData
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCredentialResponseData
     */
    'full_name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserCredentialResponseData
     */
    'is_admin'?: boolean;
    /**
     * 
     * @type {UserCredentialResponseDataOrgs}
     * @memberof UserCredentialResponseData
     */
    'orgs'?: UserCredentialResponseDataOrgs;
    /**
     * 
     * @type {Array<RoleDetail>}
     * @memberof UserCredentialResponseData
     */
    'roles'?: Array<RoleDetail>;
}
/**
 * 
 * @export
 * @interface UserCredentialResponseDataOrgs
 */
export interface UserCredentialResponseDataOrgs {
    /**
     * 
     * @type {number}
     * @memberof UserCredentialResponseDataOrgs
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserCredentialResponseDataOrgs
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface UserCredentials
 */
export interface UserCredentials {
    /**
     * 
     * @type {string}
     * @memberof UserCredentials
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserCredentials
     */
    'password': string;
}
/**
 * user detail information
 * @export
 * @interface UserDetail
 */
export interface UserDetail {
    /**
     * 
     * @type {number}
     * @memberof UserDetail
     */
    'id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof UserDetail
     */
    'is_admin'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserDetail
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDetail
     */
    'full_name'?: string;
    /**
     * 
     * @type {UserCredentialResponseDataOrgs}
     * @memberof UserDetail
     */
    'orgs'?: UserCredentialResponseDataOrgs;
    /**
     * 
     * @type {Array<RoleDetail>}
     * @memberof UserDetail
     */
    'roles'?: Array<RoleDetail>;
    /**
     * 
     * @type {boolean}
     * @memberof UserDetail
     */
    'status'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserDetail
     */
    'last_Login'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDetail
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDetail
     */
    'updated_at'?: string;
}
/**
 * user detail information
 * @export
 * @interface UserDetailNew
 */
export interface UserDetailNew {
    /**
     * 
     * @type {number}
     * @memberof UserDetailNew
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserDetailNew
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDetailNew
     */
    'full_name'?: string;
    /**
     * 
     * @type {Array<RoleDetail>}
     * @memberof UserDetailNew
     */
    'roles'?: Array<RoleDetail>;
    /**
     * 
     * @type {boolean}
     * @memberof UserDetailNew
     */
    'status'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserDetailNew
     */
    'last_Login'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDetailNew
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDetailNew
     */
    'updatedat'?: string;
}
/**
 * Check users active
 * @export
 * @interface UserIsActiveRequest
 */
export interface UserIsActiveRequest {
    /**
     * 
     * @type {number}
     * @memberof UserIsActiveRequest
     */
    'id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof UserIsActiveRequest
     */
    'is_active'?: boolean;
}
/**
 * list user detail
 * @export
 * @interface UserListResponse
 */
export interface UserListResponse {
    /**
     * 
     * @type {number}
     * @memberof UserListResponse
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserListResponse
     */
    'limit'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserListResponse
     */
    'sort'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserListResponse
     */
    'total'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserListResponse
     */
    'totalPage'?: number;
    /**
     * 
     * @type {Array<UserDetailNew>}
     * @memberof UserListResponse
     */
    'list'?: Array<UserDetailNew>;
}
/**
 * update role for user
 * @export
 * @interface UserRoleUpdate
 */
export interface UserRoleUpdate {
    /**
     * 
     * @type {number}
     * @memberof UserRoleUpdate
     */
    'id'?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof UserRoleUpdate
     */
    'role_ids'?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof UserRoleUpdate
     */
    'user_name'?: string;
}
/**
 * Withdraw detail information
 * @export
 * @interface WithdrawRequest
 */
export interface WithdrawRequest {
    /**
     * 
     * @type {number}
     * @memberof WithdrawRequest
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof WithdrawRequest
     */
    'title'?: string;
    /**
     * 
     * @type {number}
     * @memberof WithdrawRequest
     */
    'contract_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof WithdrawRequest
     */
    'project_contractor_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof WithdrawRequest
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof WithdrawRequest
     */
    'request_date'?: string;
    /**
     * 
     * @type {WithdrawRequestStatus}
     * @memberof WithdrawRequest
     */
    'status'?: WithdrawRequestStatus;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const WithdrawRequestStatus = {
    New: 'new',
    ReadyToCollect: 'ready_to_collect',
    Collected: 'collected',
    Cancelled: 'cancelled'
} as const;

export type WithdrawRequestStatus = typeof WithdrawRequestStatus[keyof typeof WithdrawRequestStatus];



/**
 * AdminApi - axios parameter creator
 * @export
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * only admin can list all permission
         * @summary list all permission list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authPermissionsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/permissions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * only admin can list all roles
         * @summary list all role list
         * @param {string} [filter] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [sortBy] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRolesGet: async (filter?: string, offset?: number, limit?: number, sortBy?: string, orderBy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/roles/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRolesIdGet: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('authRolesIdGet', 'id', id)
            const localVarPath = `/auth/roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Admins reset password for users
         * @summary Admins reset password for users
         * @param {AdminResetPassword} [adminResetPassword] Userid with new password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersAdminResetPasswordPut: async (adminResetPassword?: AdminResetPassword, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/admin-reset-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminResetPassword, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update users role
         * @summary update users role
         * @param {UserRoleUpdate} [userRoleUpdate] userid and role need to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersAssignRolePut: async (userRoleUpdate?: UserRoleUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/assign-role`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userRoleUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new users
         * @summary Create new users
         * @param {UserCreate} [userCreate] Access token is used by admin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCreatePost: async (userCreate?: UserCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new users
         * @summary Create new users
         * @param {CreateRoleRequest} [createRoleRequest] Access token is used by admin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCreateRolePost: async (createRoleRequest?: CreateRoleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/create-role`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRoleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * only admin can list all users
         * @summary list all users
         * @param {string} [filter] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [sortBy] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet: async (filter?: string, offset?: number, limit?: number, sortBy?: string, orderBy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdGet: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersIdGet', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User\'s status
         * @summary Activate and deactivate an account user
         * @param {UserIsActiveRequest} [userIsActiveRequest] Users active or not
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIsActivePut: async (userIsActiveRequest?: UserIsActiveRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/is-active`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userIsActiveRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminApi - functional programming interface
 * @export
 */
export const AdminApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminApiAxiosParamCreator(configuration)
    return {
        /**
         * only admin can list all permission
         * @summary list all permission list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authPermissionsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PermissionNewDetail>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authPermissionsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * only admin can list all roles
         * @summary list all role list
         * @param {string} [filter] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [sortBy] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authRolesGet(filter?: string, offset?: number, limit?: number, sortBy?: string, orderBy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleListByIdDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authRolesGet(filter, offset, limit, sortBy, orderBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authRolesIdGet(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleListByIdDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authRolesIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Admins reset password for users
         * @summary Admins reset password for users
         * @param {AdminResetPassword} [adminResetPassword] Userid with new password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersAdminResetPasswordPut(adminResetPassword?: AdminResetPassword, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersAdminResetPasswordPut(adminResetPassword, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * update users role
         * @summary update users role
         * @param {UserRoleUpdate} [userRoleUpdate] userid and role need to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersAssignRolePut(userRoleUpdate?: UserRoleUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersAssignRolePut(userRoleUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create new users
         * @summary Create new users
         * @param {UserCreate} [userCreate] Access token is used by admin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersCreatePost(userCreate?: UserCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersCreatePost(userCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create new users
         * @summary Create new users
         * @param {CreateRoleRequest} [createRoleRequest] Access token is used by admin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersCreateRolePost(createRoleRequest?: CreateRoleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersCreateRolePost(createRoleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * only admin can list all users
         * @summary list all users
         * @param {string} [filter] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [sortBy] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersGet(filter?: string, offset?: number, limit?: number, sortBy?: string, orderBy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersGet(filter, offset, limit, sortBy, orderBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersIdGet(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDetailNew>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User\'s status
         * @summary Activate and deactivate an account user
         * @param {UserIsActiveRequest} [userIsActiveRequest] Users active or not
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersIsActivePut(userIsActiveRequest?: UserIsActiveRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersIsActivePut(userIsActiveRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AdminApi - factory interface
 * @export
 */
export const AdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminApiFp(configuration)
    return {
        /**
         * only admin can list all permission
         * @summary list all permission list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authPermissionsGet(options?: any): AxiosPromise<Array<PermissionNewDetail>> {
            return localVarFp.authPermissionsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * only admin can list all roles
         * @summary list all role list
         * @param {string} [filter] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [sortBy] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRolesGet(filter?: string, offset?: number, limit?: number, sortBy?: string, orderBy?: string, options?: any): AxiosPromise<RoleListByIdDetail> {
            return localVarFp.authRolesGet(filter, offset, limit, sortBy, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRolesIdGet(id: number, options?: any): AxiosPromise<RoleListByIdDetail> {
            return localVarFp.authRolesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Admins reset password for users
         * @summary Admins reset password for users
         * @param {AdminResetPassword} [adminResetPassword] Userid with new password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersAdminResetPasswordPut(adminResetPassword?: AdminResetPassword, options?: any): AxiosPromise<Response> {
            return localVarFp.usersAdminResetPasswordPut(adminResetPassword, options).then((request) => request(axios, basePath));
        },
        /**
         * update users role
         * @summary update users role
         * @param {UserRoleUpdate} [userRoleUpdate] userid and role need to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersAssignRolePut(userRoleUpdate?: UserRoleUpdate, options?: any): AxiosPromise<void> {
            return localVarFp.usersAssignRolePut(userRoleUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new users
         * @summary Create new users
         * @param {UserCreate} [userCreate] Access token is used by admin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCreatePost(userCreate?: UserCreate, options?: any): AxiosPromise<Response> {
            return localVarFp.usersCreatePost(userCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new users
         * @summary Create new users
         * @param {CreateRoleRequest} [createRoleRequest] Access token is used by admin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCreateRolePost(createRoleRequest?: CreateRoleRequest, options?: any): AxiosPromise<Response> {
            return localVarFp.usersCreateRolePost(createRoleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * only admin can list all users
         * @summary list all users
         * @param {string} [filter] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [sortBy] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet(filter?: string, offset?: number, limit?: number, sortBy?: string, orderBy?: string, options?: any): AxiosPromise<UserListResponse> {
            return localVarFp.usersGet(filter, offset, limit, sortBy, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdGet(id: number, options?: any): AxiosPromise<UserDetailNew> {
            return localVarFp.usersIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * User\'s status
         * @summary Activate and deactivate an account user
         * @param {UserIsActiveRequest} [userIsActiveRequest] Users active or not
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIsActivePut(userIsActiveRequest?: UserIsActiveRequest, options?: any): AxiosPromise<Response> {
            return localVarFp.usersIsActivePut(userIsActiveRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminApi - object-oriented interface
 * @export
 * @class AdminApi
 * @extends {BaseAPI}
 */
export class AdminApi extends BaseAPI {
    /**
     * only admin can list all permission
     * @summary list all permission list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public authPermissionsGet(options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).authPermissionsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * only admin can list all roles
     * @summary list all role list
     * @param {string} [filter] 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {string} [sortBy] 
     * @param {string} [orderBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public authRolesGet(filter?: string, offset?: number, limit?: number, sortBy?: string, orderBy?: string, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).authRolesGet(filter, offset, limit, sortBy, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public authRolesIdGet(id: number, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).authRolesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Admins reset password for users
     * @summary Admins reset password for users
     * @param {AdminResetPassword} [adminResetPassword] Userid with new password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public usersAdminResetPasswordPut(adminResetPassword?: AdminResetPassword, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).usersAdminResetPasswordPut(adminResetPassword, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update users role
     * @summary update users role
     * @param {UserRoleUpdate} [userRoleUpdate] userid and role need to be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public usersAssignRolePut(userRoleUpdate?: UserRoleUpdate, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).usersAssignRolePut(userRoleUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new users
     * @summary Create new users
     * @param {UserCreate} [userCreate] Access token is used by admin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public usersCreatePost(userCreate?: UserCreate, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).usersCreatePost(userCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new users
     * @summary Create new users
     * @param {CreateRoleRequest} [createRoleRequest] Access token is used by admin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public usersCreateRolePost(createRoleRequest?: CreateRoleRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).usersCreateRolePost(createRoleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * only admin can list all users
     * @summary list all users
     * @param {string} [filter] 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {string} [sortBy] 
     * @param {string} [orderBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public usersGet(filter?: string, offset?: number, limit?: number, sortBy?: string, orderBy?: string, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).usersGet(filter, offset, limit, sortBy, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public usersIdGet(id: number, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).usersIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User\'s status
     * @summary Activate and deactivate an account user
     * @param {UserIsActiveRequest} [userIsActiveRequest] Users active or not
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public usersIsActivePut(userIsActiveRequest?: UserIsActiveRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).usersIsActivePut(userIsActiveRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Check email and send link to reset password
         * @summary Forgot password
         * @param {ForgotPassword} [forgotPassword] Request Email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authForgotPasswordPost: async (forgotPassword?: ForgotPassword, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/forgot-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(forgotPassword, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Login by Email and Password 
         * @param {UserCredentials} [userCredentials] email and password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLoginPost: async (userCredentials?: UserCredentials, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCredentials, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Users can only log themselves out, not other users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLogoutPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * only admin can list all roles
         * @summary list all roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRolesGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * link to reset password
         * @summary reset password
         * @param {ResetPassword} [resetPassword] Need password to change
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersResetPasswordPut: async (resetPassword?: ResetPassword, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/reset-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetPassword, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Check email and send link to reset password
         * @summary Forgot password
         * @param {ForgotPassword} [forgotPassword] Request Email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authForgotPasswordPost(forgotPassword?: ForgotPassword, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authForgotPasswordPost(forgotPassword, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Login by Email and Password 
         * @param {UserCredentials} [userCredentials] email and password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authLoginPost(userCredentials?: UserCredentials, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCredentialResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authLoginPost(userCredentials, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Users can only log themselves out, not other users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authLogoutPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authLogoutPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * only admin can list all roles
         * @summary list all roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authRolesGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authRolesGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * link to reset password
         * @summary reset password
         * @param {ResetPassword} [resetPassword] Need password to change
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersResetPasswordPut(resetPassword?: ResetPassword, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersResetPasswordPut(resetPassword, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Check email and send link to reset password
         * @summary Forgot password
         * @param {ForgotPassword} [forgotPassword] Request Email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authForgotPasswordPost(forgotPassword?: ForgotPassword, options?: any): AxiosPromise<Response> {
            return localVarFp.authForgotPasswordPost(forgotPassword, options).then((request) => request(axios, basePath));
        },
        /**
         * User Login by Email and Password 
         * @param {UserCredentials} [userCredentials] email and password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLoginPost(userCredentials?: UserCredentials, options?: any): AxiosPromise<UserCredentialResponse> {
            return localVarFp.authLoginPost(userCredentials, options).then((request) => request(axios, basePath));
        },
        /**
         * Users can only log themselves out, not other users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLogoutPost(options?: any): AxiosPromise<void> {
            return localVarFp.authLogoutPost(options).then((request) => request(axios, basePath));
        },
        /**
         * only admin can list all roles
         * @summary list all roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRolesGet(options?: any): AxiosPromise<RoleListResponse> {
            return localVarFp.authRolesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * link to reset password
         * @summary reset password
         * @param {ResetPassword} [resetPassword] Need password to change
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersResetPasswordPut(resetPassword?: ResetPassword, options?: any): AxiosPromise<Response> {
            return localVarFp.usersResetPasswordPut(resetPassword, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * Check email and send link to reset password
     * @summary Forgot password
     * @param {ForgotPassword} [forgotPassword] Request Email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authForgotPasswordPost(forgotPassword?: ForgotPassword, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authForgotPasswordPost(forgotPassword, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Login by Email and Password 
     * @param {UserCredentials} [userCredentials] email and password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authLoginPost(userCredentials?: UserCredentials, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authLoginPost(userCredentials, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Users can only log themselves out, not other users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authLogoutPost(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authLogoutPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * only admin can list all roles
     * @summary list all roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authRolesGet(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authRolesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * link to reset password
     * @summary reset password
     * @param {ResetPassword} [resetPassword] Need password to change
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public usersResetPasswordPut(resetPassword?: ResetPassword, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).usersResetPasswordPut(resetPassword, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ContractApi - axios parameter creator
 * @export
 */
export const ContractApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} contractId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsContractIdGet: async (contractId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('contractsContractIdGet', 'contractId', contractId)
            const localVarPath = `/contracts/{contract_id}`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get and filter contracts
         * @summary get and filter contracts
         * @param {string} [q] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [sortBy] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsGet: async (q?: string, offset?: number, limit?: number, sortBy?: string, orderBy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/contracts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContractApi - functional programming interface
 * @export
 */
export const ContractApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContractApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} contractId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsContractIdGet(contractId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Contract>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsContractIdGet(contractId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * get and filter contracts
         * @summary get and filter contracts
         * @param {string} [q] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [sortBy] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsGet(q?: string, offset?: number, limit?: number, sortBy?: string, orderBy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsGet(q, offset, limit, sortBy, orderBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContractApi - factory interface
 * @export
 */
export const ContractApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContractApiFp(configuration)
    return {
        /**
         * 
         * @param {number} contractId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsContractIdGet(contractId: number, options?: any): AxiosPromise<Contract> {
            return localVarFp.contractsContractIdGet(contractId, options).then((request) => request(axios, basePath));
        },
        /**
         * get and filter contracts
         * @summary get and filter contracts
         * @param {string} [q] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [sortBy] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsGet(q?: string, offset?: number, limit?: number, sortBy?: string, orderBy?: string, options?: any): AxiosPromise<ContractListResponse> {
            return localVarFp.contractsGet(q, offset, limit, sortBy, orderBy, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContractApi - object-oriented interface
 * @export
 * @class ContractApi
 * @extends {BaseAPI}
 */
export class ContractApi extends BaseAPI {
    /**
     * 
     * @param {number} contractId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractApi
     */
    public contractsContractIdGet(contractId: number, options?: AxiosRequestConfig) {
        return ContractApiFp(this.configuration).contractsContractIdGet(contractId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get and filter contracts
     * @summary get and filter contracts
     * @param {string} [q] 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {string} [sortBy] 
     * @param {string} [orderBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractApi
     */
    public contractsGet(q?: string, offset?: number, limit?: number, sortBy?: string, orderBy?: string, options?: AxiosRequestConfig) {
        return ContractApiFp(this.configuration).contractsGet(q, offset, limit, sortBy, orderBy, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Update user\'s full name
         * @summary Update user\'s full name
         * @param {UpdateUserNameRequest} [updateUserNameRequest] Userid and role need to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersNamePut: async (updateUserNameRequest?: UpdateUserNameRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/name`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserNameRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * Update user\'s full name
         * @summary Update user\'s full name
         * @param {UpdateUserNameRequest} [updateUserNameRequest] Userid and role need to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersNamePut(updateUserNameRequest?: UpdateUserNameRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersNamePut(updateUserNameRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * Update user\'s full name
         * @summary Update user\'s full name
         * @param {UpdateUserNameRequest} [updateUserNameRequest] Userid and role need to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersNamePut(updateUserNameRequest?: UpdateUserNameRequest, options?: any): AxiosPromise<Response> {
            return localVarFp.usersNamePut(updateUserNameRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * Update user\'s full name
     * @summary Update user\'s full name
     * @param {UpdateUserNameRequest} [updateUserNameRequest] Userid and role need to be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersNamePut(updateUserNameRequest?: UpdateUserNameRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).usersNamePut(updateUserNameRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WithDrawRequestApi - axios parameter creator
 * @export
 */
export const WithDrawRequestApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [q] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [sortBy] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        withdrawRequestsGet: async (q?: string, offset?: number, limit?: number, sortBy?: string, orderBy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/withdraw_requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * create new withdraw request
         * @summary create new withdraw request
         * @param {WithdrawRequest} [withdrawRequest] filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        withdrawRequestsPost: async (withdrawRequest?: WithdrawRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/withdraw_requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(withdrawRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} withdrawId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        withdrawRequestsWithdrawIdCancelPost: async (withdrawId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'withdrawId' is not null or undefined
            assertParamExists('withdrawRequestsWithdrawIdCancelPost', 'withdrawId', withdrawId)
            const localVarPath = `/withdraw_requests/{withdraw_id}/cancel`
                .replace(`{${"withdraw_id"}}`, encodeURIComponent(String(withdrawId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} withdrawId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        withdrawRequestsWithdrawIdGet: async (withdrawId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'withdrawId' is not null or undefined
            assertParamExists('withdrawRequestsWithdrawIdGet', 'withdrawId', withdrawId)
            const localVarPath = `/withdraw_requests/{withdraw_id}`
                .replace(`{${"withdraw_id"}}`, encodeURIComponent(String(withdrawId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update WithdrawRequest
         * @summary update withdraw request
         * @param {number} withdrawId 
         * @param {WithdrawRequest} [withdrawRequest] filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        withdrawRequestsWithdrawIdPut: async (withdrawId: number, withdrawRequest?: WithdrawRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'withdrawId' is not null or undefined
            assertParamExists('withdrawRequestsWithdrawIdPut', 'withdrawId', withdrawId)
            const localVarPath = `/withdraw_requests/{withdraw_id}`
                .replace(`{${"withdraw_id"}}`, encodeURIComponent(String(withdrawId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(withdrawRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} withdrawId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        withdrawRequestsWithdrawIdUpdateStatusToCollectedPost: async (withdrawId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'withdrawId' is not null or undefined
            assertParamExists('withdrawRequestsWithdrawIdUpdateStatusToCollectedPost', 'withdrawId', withdrawId)
            const localVarPath = `/withdraw_requests/{withdraw_id}/update-status-to-collected`
                .replace(`{${"withdraw_id"}}`, encodeURIComponent(String(withdrawId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} withdrawId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        withdrawRequestsWithdrawIdUpdateStatusToReadyToCollectPost: async (withdrawId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'withdrawId' is not null or undefined
            assertParamExists('withdrawRequestsWithdrawIdUpdateStatusToReadyToCollectPost', 'withdrawId', withdrawId)
            const localVarPath = `/withdraw_requests/{withdraw_id}/update-status-to-ready-to-collect`
                .replace(`{${"withdraw_id"}}`, encodeURIComponent(String(withdrawId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WithDrawRequestApi - functional programming interface
 * @export
 */
export const WithDrawRequestApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WithDrawRequestApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [q] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [sortBy] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async withdrawRequestsGet(q?: string, offset?: number, limit?: number, sortBy?: string, orderBy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListWithdrawRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.withdrawRequestsGet(q, offset, limit, sortBy, orderBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * create new withdraw request
         * @summary create new withdraw request
         * @param {WithdrawRequest} [withdrawRequest] filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async withdrawRequestsPost(withdrawRequest?: WithdrawRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WithdrawRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.withdrawRequestsPost(withdrawRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} withdrawId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async withdrawRequestsWithdrawIdCancelPost(withdrawId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WithdrawRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.withdrawRequestsWithdrawIdCancelPost(withdrawId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} withdrawId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async withdrawRequestsWithdrawIdGet(withdrawId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WithdrawRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.withdrawRequestsWithdrawIdGet(withdrawId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * update WithdrawRequest
         * @summary update withdraw request
         * @param {number} withdrawId 
         * @param {WithdrawRequest} [withdrawRequest] filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async withdrawRequestsWithdrawIdPut(withdrawId: number, withdrawRequest?: WithdrawRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.withdrawRequestsWithdrawIdPut(withdrawId, withdrawRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} withdrawId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async withdrawRequestsWithdrawIdUpdateStatusToCollectedPost(withdrawId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WithdrawRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.withdrawRequestsWithdrawIdUpdateStatusToCollectedPost(withdrawId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} withdrawId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async withdrawRequestsWithdrawIdUpdateStatusToReadyToCollectPost(withdrawId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WithdrawRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.withdrawRequestsWithdrawIdUpdateStatusToReadyToCollectPost(withdrawId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WithDrawRequestApi - factory interface
 * @export
 */
export const WithDrawRequestApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WithDrawRequestApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [q] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [sortBy] 
         * @param {string} [orderBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        withdrawRequestsGet(q?: string, offset?: number, limit?: number, sortBy?: string, orderBy?: string, options?: any): AxiosPromise<ListWithdrawRequest> {
            return localVarFp.withdrawRequestsGet(q, offset, limit, sortBy, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * create new withdraw request
         * @summary create new withdraw request
         * @param {WithdrawRequest} [withdrawRequest] filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        withdrawRequestsPost(withdrawRequest?: WithdrawRequest, options?: any): AxiosPromise<WithdrawRequest> {
            return localVarFp.withdrawRequestsPost(withdrawRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} withdrawId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        withdrawRequestsWithdrawIdCancelPost(withdrawId: number, options?: any): AxiosPromise<WithdrawRequest> {
            return localVarFp.withdrawRequestsWithdrawIdCancelPost(withdrawId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} withdrawId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        withdrawRequestsWithdrawIdGet(withdrawId: number, options?: any): AxiosPromise<WithdrawRequest> {
            return localVarFp.withdrawRequestsWithdrawIdGet(withdrawId, options).then((request) => request(axios, basePath));
        },
        /**
         * update WithdrawRequest
         * @summary update withdraw request
         * @param {number} withdrawId 
         * @param {WithdrawRequest} [withdrawRequest] filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        withdrawRequestsWithdrawIdPut(withdrawId: number, withdrawRequest?: WithdrawRequest, options?: any): AxiosPromise<void> {
            return localVarFp.withdrawRequestsWithdrawIdPut(withdrawId, withdrawRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} withdrawId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        withdrawRequestsWithdrawIdUpdateStatusToCollectedPost(withdrawId: number, options?: any): AxiosPromise<WithdrawRequest> {
            return localVarFp.withdrawRequestsWithdrawIdUpdateStatusToCollectedPost(withdrawId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} withdrawId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        withdrawRequestsWithdrawIdUpdateStatusToReadyToCollectPost(withdrawId: number, options?: any): AxiosPromise<WithdrawRequest> {
            return localVarFp.withdrawRequestsWithdrawIdUpdateStatusToReadyToCollectPost(withdrawId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WithDrawRequestApi - object-oriented interface
 * @export
 * @class WithDrawRequestApi
 * @extends {BaseAPI}
 */
export class WithDrawRequestApi extends BaseAPI {
    /**
     * 
     * @param {string} [q] 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {string} [sortBy] 
     * @param {string} [orderBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WithDrawRequestApi
     */
    public withdrawRequestsGet(q?: string, offset?: number, limit?: number, sortBy?: string, orderBy?: string, options?: AxiosRequestConfig) {
        return WithDrawRequestApiFp(this.configuration).withdrawRequestsGet(q, offset, limit, sortBy, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * create new withdraw request
     * @summary create new withdraw request
     * @param {WithdrawRequest} [withdrawRequest] filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WithDrawRequestApi
     */
    public withdrawRequestsPost(withdrawRequest?: WithdrawRequest, options?: AxiosRequestConfig) {
        return WithDrawRequestApiFp(this.configuration).withdrawRequestsPost(withdrawRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} withdrawId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WithDrawRequestApi
     */
    public withdrawRequestsWithdrawIdCancelPost(withdrawId: number, options?: AxiosRequestConfig) {
        return WithDrawRequestApiFp(this.configuration).withdrawRequestsWithdrawIdCancelPost(withdrawId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} withdrawId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WithDrawRequestApi
     */
    public withdrawRequestsWithdrawIdGet(withdrawId: number, options?: AxiosRequestConfig) {
        return WithDrawRequestApiFp(this.configuration).withdrawRequestsWithdrawIdGet(withdrawId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update WithdrawRequest
     * @summary update withdraw request
     * @param {number} withdrawId 
     * @param {WithdrawRequest} [withdrawRequest] filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WithDrawRequestApi
     */
    public withdrawRequestsWithdrawIdPut(withdrawId: number, withdrawRequest?: WithdrawRequest, options?: AxiosRequestConfig) {
        return WithDrawRequestApiFp(this.configuration).withdrawRequestsWithdrawIdPut(withdrawId, withdrawRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} withdrawId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WithDrawRequestApi
     */
    public withdrawRequestsWithdrawIdUpdateStatusToCollectedPost(withdrawId: number, options?: AxiosRequestConfig) {
        return WithDrawRequestApiFp(this.configuration).withdrawRequestsWithdrawIdUpdateStatusToCollectedPost(withdrawId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} withdrawId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WithDrawRequestApi
     */
    public withdrawRequestsWithdrawIdUpdateStatusToReadyToCollectPost(withdrawId: number, options?: AxiosRequestConfig) {
        return WithDrawRequestApiFp(this.configuration).withdrawRequestsWithdrawIdUpdateStatusToReadyToCollectPost(withdrawId, options).then((request) => request(this.axios, this.basePath));
    }
}


